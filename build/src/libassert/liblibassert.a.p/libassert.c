/* libassert.c generated by valac 0.50.2, the Vala compiler
 * generated from libassert.vala, do not modify */

#include "libassert.h"
#include <gee.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>

enum  {
	ASSERT_TEST_SUITE_INSTANCE_0_PROPERTY,
	ASSERT_TEST_SUITE_INSTANCE_NUM_PROPERTIES
};
static GParamSpec* assert_test_suite_instance_properties[ASSERT_TEST_SUITE_INSTANCE_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _assert_named_test_case_free0(var) ((var == NULL) ? NULL : (var = (assert_named_test_case_free (var), NULL)))
typedef struct _AssertParamSpecAssertionResult AssertParamSpecAssertionResult;

struct _AssertTestSuiteInstancePrivate {
	GeeArrayList* cases;
	gchar* name;
};

struct _AssertParamSpecAssertionResult {
	GParamSpec parent_instance;
};

static gint AssertTestSuiteInstance_private_offset;
static gpointer assert_test_suite_instance_parent_class = NULL;
static gpointer assert_assertion_result_parent_class = NULL;

static void assert_test_suite_instance_finalize (GObject * obj);
static GType assert_test_suite_instance_get_type_once (void);
static void assert_assertion_result_finalize (AssertAssertionResult * obj);
static GType assert_assertion_result_get_type_once (void);

static inline gpointer
assert_test_suite_instance_get_instance_private (AssertTestSuiteInstance* self)
{
	return G_STRUCT_MEMBER_P (self, AssertTestSuiteInstance_private_offset);
}

void
assert_test_suite_instance_it (AssertTestSuiteInstance* self,
                               const gchar* name,
                               AssertTestCase tcase,
                               gpointer tcase_target)
{
	GeeArrayList* _tmp0_;
	gchar* _tmp1_;
	AssertNamedTestCase _tmp2_ = {0};
	AssertNamedTestCase _tmp3_;
	AssertNamedTestCase _tmp4_;
#line 6 "../src/libassert/libassert.vala"
	g_return_if_fail (self != NULL);
#line 6 "../src/libassert/libassert.vala"
	g_return_if_fail (name != NULL);
#line 7 "../src/libassert/libassert.vala"
	_tmp0_ = self->priv->cases;
#line 7 "../src/libassert/libassert.vala"
	_tmp1_ = g_strdup (name);
#line 7 "../src/libassert/libassert.vala"
	memset (&_tmp2_, 0, sizeof (AssertNamedTestCase));
#line 7 "../src/libassert/libassert.vala"
	_g_free0 (_tmp2_.name);
#line 7 "../src/libassert/libassert.vala"
	_tmp2_.name = _tmp1_;
#line 7 "../src/libassert/libassert.vala"
	(_tmp2_.tcase_target_destroy_notify == NULL) ? NULL : (_tmp2_.tcase_target_destroy_notify (_tmp2_.tcase_target), NULL);
#line 7 "../src/libassert/libassert.vala"
	_tmp2_.tcase = NULL;
#line 7 "../src/libassert/libassert.vala"
	_tmp2_.tcase_target = NULL;
#line 7 "../src/libassert/libassert.vala"
	_tmp2_.tcase_target_destroy_notify = NULL;
#line 7 "../src/libassert/libassert.vala"
	_tmp2_.tcase = tcase;
#line 7 "../src/libassert/libassert.vala"
	_tmp2_.tcase_target = tcase_target;
#line 7 "../src/libassert/libassert.vala"
	_tmp2_.tcase_target_destroy_notify = NULL;
#line 7 "../src/libassert/libassert.vala"
	_tmp3_ = _tmp2_;
#line 7 "../src/libassert/libassert.vala"
	_tmp4_ = _tmp3_;
#line 7 "../src/libassert/libassert.vala"
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp0_, &_tmp4_);
#line 7 "../src/libassert/libassert.vala"
	assert_named_test_case_destroy (&_tmp3_);
#line 95 "libassert.c"
}

static gpointer
_g_object_ref0 (gpointer self)
{
#line 15 "../src/libassert/libassert.vala"
	return self ? g_object_ref (self) : NULL;
#line 103 "libassert.c"
}

static const gchar*
string_to_string (const gchar* self)
{
	const gchar* result = NULL;
#line 1570 "glib-2.0.vapi"
	g_return_val_if_fail (self != NULL, NULL);
#line 1571 "glib-2.0.vapi"
	result = self;
#line 1571 "glib-2.0.vapi"
	return result;
#line 116 "libassert.c"
}

void
assert_test_suite_instance_run (AssertTestSuiteInstance* self)
{
	GeeArrayList* successes = NULL;
	AssertNamedTestCase* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* failures = NULL;
	AssertNamedTestCase* _tmp2_;
	GeeArrayList* _tmp3_;
	FILE* _tmp19_;
	const gchar* _tmp20_;
	const gchar* _tmp21_;
	gchar* _tmp22_;
	gchar* _tmp23_;
	FILE* _tmp24_;
	FILE* _tmp41_;
	GError* _inner_error0_ = NULL;
#line 12 "../src/libassert/libassert.vala"
	g_return_if_fail (self != NULL);
#line 13 "../src/libassert/libassert.vala"
	_tmp0_ = g_new0 (AssertNamedTestCase, 0);
#line 13 "../src/libassert/libassert.vala"
	_tmp1_ = gee_array_list_new_wrap (ASSERT_TYPE_NAMED_TEST_CASE, (GBoxedCopyFunc) assert_named_test_case_dup, (GDestroyNotify) assert_named_test_case_destroy, _tmp0_, 0, NULL, NULL, NULL);
#line 13 "../src/libassert/libassert.vala"
	successes = _tmp1_;
#line 14 "../src/libassert/libassert.vala"
	_tmp2_ = g_new0 (AssertNamedTestCase, 0);
#line 14 "../src/libassert/libassert.vala"
	_tmp3_ = gee_array_list_new_wrap (ASSERT_TYPE_NAMED_TEST_CASE, (GBoxedCopyFunc) assert_named_test_case_dup, (GDestroyNotify) assert_named_test_case_destroy, _tmp2_, 0, NULL, NULL, NULL);
#line 14 "../src/libassert/libassert.vala"
	failures = _tmp3_;
#line 150 "libassert.c"
	{
		GeeArrayList* _tcase_list = NULL;
		GeeArrayList* _tmp4_;
		GeeArrayList* _tmp5_;
		gint _tcase_size = 0;
		GeeArrayList* _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		gint _tcase_index = 0;
#line 15 "../src/libassert/libassert.vala"
		_tmp4_ = self->priv->cases;
#line 15 "../src/libassert/libassert.vala"
		_tmp5_ = _g_object_ref0 (_tmp4_);
#line 15 "../src/libassert/libassert.vala"
		_tcase_list = _tmp5_;
#line 15 "../src/libassert/libassert.vala"
		_tmp6_ = _tcase_list;
#line 15 "../src/libassert/libassert.vala"
		_tmp7_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp6_);
#line 15 "../src/libassert/libassert.vala"
		_tmp8_ = _tmp7_;
#line 15 "../src/libassert/libassert.vala"
		_tcase_size = _tmp8_;
#line 15 "../src/libassert/libassert.vala"
		_tcase_index = -1;
#line 15 "../src/libassert/libassert.vala"
		while (TRUE) {
#line 178 "libassert.c"
			gint _tmp9_;
			gint _tmp10_;
			AssertNamedTestCase* tcase = NULL;
			GeeArrayList* _tmp11_;
			gpointer _tmp12_;
#line 15 "../src/libassert/libassert.vala"
			_tcase_index = _tcase_index + 1;
#line 15 "../src/libassert/libassert.vala"
			_tmp9_ = _tcase_index;
#line 15 "../src/libassert/libassert.vala"
			_tmp10_ = _tcase_size;
#line 15 "../src/libassert/libassert.vala"
			if (!(_tmp9_ < _tmp10_)) {
#line 15 "../src/libassert/libassert.vala"
				break;
#line 194 "libassert.c"
			}
#line 15 "../src/libassert/libassert.vala"
			_tmp11_ = _tcase_list;
#line 15 "../src/libassert/libassert.vala"
			_tmp12_ = gee_abstract_list_get ((GeeAbstractList*) _tmp11_, _tcase_index);
#line 15 "../src/libassert/libassert.vala"
			tcase = (AssertNamedTestCase*) _tmp12_;
#line 202 "libassert.c"
			{
				AssertNamedTestCase* _tmp13_;
				AssertTestCase _tmp14_;
				gpointer _tmp14__target;
				GeeArrayList* _tmp15_;
				AssertNamedTestCase* _tmp16_;
#line 17 "../src/libassert/libassert.vala"
				_tmp13_ = tcase;
#line 17 "../src/libassert/libassert.vala"
				_tmp14_ = (*_tmp13_).tcase;
#line 17 "../src/libassert/libassert.vala"
				_tmp14__target = (*_tmp13_).tcase_target;
#line 17 "../src/libassert/libassert.vala"
				_tmp14_ (_tmp14__target, &_inner_error0_);
#line 17 "../src/libassert/libassert.vala"
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 219 "libassert.c"
					goto __catch0_g_error;
				}
#line 18 "../src/libassert/libassert.vala"
				_tmp15_ = successes;
#line 18 "../src/libassert/libassert.vala"
				_tmp16_ = tcase;
#line 18 "../src/libassert/libassert.vala"
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp15_, *_tmp16_);
#line 228 "libassert.c"
			}
			goto __finally0;
			__catch0_g_error:
			{
				GeeArrayList* _tmp17_;
				AssertNamedTestCase* _tmp18_;
#line 16 "../src/libassert/libassert.vala"
				g_clear_error (&_inner_error0_);
#line 20 "../src/libassert/libassert.vala"
				_tmp17_ = failures;
#line 20 "../src/libassert/libassert.vala"
				_tmp18_ = tcase;
#line 20 "../src/libassert/libassert.vala"
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp17_, *_tmp18_);
#line 243 "libassert.c"
			}
			__finally0:
#line 16 "../src/libassert/libassert.vala"
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 16 "../src/libassert/libassert.vala"
				_assert_named_test_case_free0 (tcase);
#line 16 "../src/libassert/libassert.vala"
				_g_object_unref0 (_tcase_list);
#line 16 "../src/libassert/libassert.vala"
				_g_object_unref0 (failures);
#line 16 "../src/libassert/libassert.vala"
				_g_object_unref0 (successes);
#line 16 "../src/libassert/libassert.vala"
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 16 "../src/libassert/libassert.vala"
				g_clear_error (&_inner_error0_);
#line 16 "../src/libassert/libassert.vala"
				return;
#line 262 "libassert.c"
			}
#line 15 "../src/libassert/libassert.vala"
			_assert_named_test_case_free0 (tcase);
#line 266 "libassert.c"
		}
#line 15 "../src/libassert/libassert.vala"
		_g_object_unref0 (_tcase_list);
#line 270 "libassert.c"
	}
#line 23 "../src/libassert/libassert.vala"
	_tmp19_ = stdout;
#line 23 "../src/libassert/libassert.vala"
	_tmp20_ = self->priv->name;
#line 23 "../src/libassert/libassert.vala"
	_tmp21_ = string_to_string (_tmp20_);
#line 23 "../src/libassert/libassert.vala"
	_tmp22_ = g_strconcat ("\\e[1mTest case ", _tmp21_, "\\e[0m\n", NULL);
#line 23 "../src/libassert/libassert.vala"
	_tmp23_ = _tmp22_;
#line 23 "../src/libassert/libassert.vala"
	fputs (_tmp23_, _tmp19_);
#line 23 "../src/libassert/libassert.vala"
	_g_free0 (_tmp23_);
#line 24 "../src/libassert/libassert.vala"
	_tmp24_ = stdout;
#line 24 "../src/libassert/libassert.vala"
	fputs ("\\e[32mSuccesses:\\e[0m\n", _tmp24_);
#line 290 "libassert.c"
	{
		GeeArrayList* _success_list = NULL;
		GeeArrayList* _tmp25_;
		GeeArrayList* _tmp26_;
		gint _success_size = 0;
		GeeArrayList* _tmp27_;
		gint _tmp28_;
		gint _tmp29_;
		gint _success_index = 0;
#line 25 "../src/libassert/libassert.vala"
		_tmp25_ = successes;
#line 25 "../src/libassert/libassert.vala"
		_tmp26_ = _g_object_ref0 (_tmp25_);
#line 25 "../src/libassert/libassert.vala"
		_success_list = _tmp26_;
#line 25 "../src/libassert/libassert.vala"
		_tmp27_ = _success_list;
#line 25 "../src/libassert/libassert.vala"
		_tmp28_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp27_);
#line 25 "../src/libassert/libassert.vala"
		_tmp29_ = _tmp28_;
#line 25 "../src/libassert/libassert.vala"
		_success_size = _tmp29_;
#line 25 "../src/libassert/libassert.vala"
		_success_index = -1;
#line 25 "../src/libassert/libassert.vala"
		while (TRUE) {
#line 318 "libassert.c"
			gint _tmp30_;
			gint _tmp31_;
			AssertNamedTestCase success = {0};
			GeeArrayList* _tmp32_;
			gpointer _tmp33_;
			FILE* _tmp34_;
			AssertNamedTestCase _tmp35_;
			const gchar* _tmp36_;
			gchar* _tmp37_;
			gchar* _tmp38_;
			gchar* _tmp39_;
			gchar* _tmp40_;
#line 25 "../src/libassert/libassert.vala"
			_success_index = _success_index + 1;
#line 25 "../src/libassert/libassert.vala"
			_tmp30_ = _success_index;
#line 25 "../src/libassert/libassert.vala"
			_tmp31_ = _success_size;
#line 25 "../src/libassert/libassert.vala"
			if (!(_tmp30_ < _tmp31_)) {
#line 25 "../src/libassert/libassert.vala"
				break;
#line 341 "libassert.c"
			}
#line 25 "../src/libassert/libassert.vala"
			_tmp32_ = _success_list;
#line 25 "../src/libassert/libassert.vala"
			_tmp33_ = gee_abstract_list_get ((GeeAbstractList*) _tmp32_, _success_index);
#line 25 "../src/libassert/libassert.vala"
			success = _tmp33_;
#line 26 "../src/libassert/libassert.vala"
			_tmp34_ = stdout;
#line 26 "../src/libassert/libassert.vala"
			_tmp35_ = success;
#line 26 "../src/libassert/libassert.vala"
			_tmp36_ = _tmp35_.name;
#line 26 "../src/libassert/libassert.vala"
			_tmp37_ = g_strconcat ("\t\\e[1;32m", _tmp36_, NULL);
#line 26 "../src/libassert/libassert.vala"
			_tmp38_ = _tmp37_;
#line 26 "../src/libassert/libassert.vala"
			_tmp39_ = g_strconcat (_tmp38_, "\\e[0m\n", NULL);
#line 26 "../src/libassert/libassert.vala"
			_tmp40_ = _tmp39_;
#line 26 "../src/libassert/libassert.vala"
			fputs (_tmp40_, _tmp34_);
#line 26 "../src/libassert/libassert.vala"
			_g_free0 (_tmp40_);
#line 26 "../src/libassert/libassert.vala"
			_g_free0 (_tmp38_);
#line 25 "../src/libassert/libassert.vala"
			assert_named_test_case_destroy (&success);
#line 371 "libassert.c"
		}
#line 25 "../src/libassert/libassert.vala"
		_g_object_unref0 (_success_list);
#line 375 "libassert.c"
	}
#line 28 "../src/libassert/libassert.vala"
	_tmp41_ = stdout;
#line 28 "../src/libassert/libassert.vala"
	fputs ("\\e[31mFailures:\\e[0m\n", _tmp41_);
#line 381 "libassert.c"
	{
		GeeArrayList* _failure_list = NULL;
		GeeArrayList* _tmp42_;
		GeeArrayList* _tmp43_;
		gint _failure_size = 0;
		GeeArrayList* _tmp44_;
		gint _tmp45_;
		gint _tmp46_;
		gint _failure_index = 0;
#line 29 "../src/libassert/libassert.vala"
		_tmp42_ = failures;
#line 29 "../src/libassert/libassert.vala"
		_tmp43_ = _g_object_ref0 (_tmp42_);
#line 29 "../src/libassert/libassert.vala"
		_failure_list = _tmp43_;
#line 29 "../src/libassert/libassert.vala"
		_tmp44_ = _failure_list;
#line 29 "../src/libassert/libassert.vala"
		_tmp45_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp44_);
#line 29 "../src/libassert/libassert.vala"
		_tmp46_ = _tmp45_;
#line 29 "../src/libassert/libassert.vala"
		_failure_size = _tmp46_;
#line 29 "../src/libassert/libassert.vala"
		_failure_index = -1;
#line 29 "../src/libassert/libassert.vala"
		while (TRUE) {
#line 409 "libassert.c"
			gint _tmp47_;
			gint _tmp48_;
			AssertNamedTestCase failure = {0};
			GeeArrayList* _tmp49_;
			gpointer _tmp50_;
			FILE* _tmp51_;
			AssertNamedTestCase _tmp52_;
			const gchar* _tmp53_;
			gchar* _tmp54_;
			gchar* _tmp55_;
			gchar* _tmp56_;
			gchar* _tmp57_;
#line 29 "../src/libassert/libassert.vala"
			_failure_index = _failure_index + 1;
#line 29 "../src/libassert/libassert.vala"
			_tmp47_ = _failure_index;
#line 29 "../src/libassert/libassert.vala"
			_tmp48_ = _failure_size;
#line 29 "../src/libassert/libassert.vala"
			if (!(_tmp47_ < _tmp48_)) {
#line 29 "../src/libassert/libassert.vala"
				break;
#line 432 "libassert.c"
			}
#line 29 "../src/libassert/libassert.vala"
			_tmp49_ = _failure_list;
#line 29 "../src/libassert/libassert.vala"
			_tmp50_ = gee_abstract_list_get ((GeeAbstractList*) _tmp49_, _failure_index);
#line 29 "../src/libassert/libassert.vala"
			failure = _tmp50_;
#line 30 "../src/libassert/libassert.vala"
			_tmp51_ = stdout;
#line 30 "../src/libassert/libassert.vala"
			_tmp52_ = failure;
#line 30 "../src/libassert/libassert.vala"
			_tmp53_ = _tmp52_.name;
#line 30 "../src/libassert/libassert.vala"
			_tmp54_ = g_strconcat ("\t\\e[1;31m", _tmp53_, NULL);
#line 30 "../src/libassert/libassert.vala"
			_tmp55_ = _tmp54_;
#line 30 "../src/libassert/libassert.vala"
			_tmp56_ = g_strconcat (_tmp55_, "\\e[0m\n", NULL);
#line 30 "../src/libassert/libassert.vala"
			_tmp57_ = _tmp56_;
#line 30 "../src/libassert/libassert.vala"
			fputs (_tmp57_, _tmp51_);
#line 30 "../src/libassert/libassert.vala"
			_g_free0 (_tmp57_);
#line 30 "../src/libassert/libassert.vala"
			_g_free0 (_tmp55_);
#line 29 "../src/libassert/libassert.vala"
			assert_named_test_case_destroy (&failure);
#line 462 "libassert.c"
		}
#line 29 "../src/libassert/libassert.vala"
		_g_object_unref0 (_failure_list);
#line 466 "libassert.c"
	}
#line 12 "../src/libassert/libassert.vala"
	_g_object_unref0 (failures);
#line 12 "../src/libassert/libassert.vala"
	_g_object_unref0 (successes);
#line 472 "libassert.c"
}

void
assert_test_suite_instance_assert (AssertTestSuiteInstance* self,
                                   gboolean condition,
                                   const gchar* message,
                                   GError** error)
{
	GError* _inner_error0_ = NULL;
#line 33 "../src/libassert/libassert.vala"
	g_return_if_fail (self != NULL);
#line 33 "../src/libassert/libassert.vala"
	g_return_if_fail (message != NULL);
#line 34 "../src/libassert/libassert.vala"
	if (!condition) {
#line 488 "libassert.c"
		GError* _tmp0_;
#line 35 "../src/libassert/libassert.vala"
		_tmp0_ = g_error_new (g_quark_from_string ("AssertionError"), 1, "%s", message);
#line 35 "../src/libassert/libassert.vala"
		_inner_error0_ = _tmp0_;
#line 35 "../src/libassert/libassert.vala"
		g_propagate_error (error, _inner_error0_);
#line 35 "../src/libassert/libassert.vala"
		return;
#line 498 "libassert.c"
	}
}

AssertTestSuiteInstance*
assert_test_suite_instance_construct (GType object_type)
{
	AssertTestSuiteInstance * self = NULL;
#line 3 "../src/libassert/libassert.vala"
	self = (AssertTestSuiteInstance*) g_object_new (object_type, NULL);
#line 3 "../src/libassert/libassert.vala"
	return self;
#line 510 "libassert.c"
}

AssertTestSuiteInstance*
assert_test_suite_instance_new (void)
{
#line 3 "../src/libassert/libassert.vala"
	return assert_test_suite_instance_construct (ASSERT_TYPE_TEST_SUITE_INSTANCE);
#line 518 "libassert.c"
}

static void
assert_test_suite_instance_class_init (AssertTestSuiteInstanceClass * klass,
                                       gpointer klass_data)
{
#line 3 "../src/libassert/libassert.vala"
	assert_test_suite_instance_parent_class = g_type_class_peek_parent (klass);
#line 3 "../src/libassert/libassert.vala"
	g_type_class_adjust_private_offset (klass, &AssertTestSuiteInstance_private_offset);
#line 3 "../src/libassert/libassert.vala"
	G_OBJECT_CLASS (klass)->finalize = assert_test_suite_instance_finalize;
#line 531 "libassert.c"
}

static void
assert_test_suite_instance_instance_init (AssertTestSuiteInstance * self,
                                          gpointer klass)
{
#line 3 "../src/libassert/libassert.vala"
	self->priv = assert_test_suite_instance_get_instance_private (self);
#line 540 "libassert.c"
}

static void
assert_test_suite_instance_finalize (GObject * obj)
{
	AssertTestSuiteInstance * self;
#line 3 "../src/libassert/libassert.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, ASSERT_TYPE_TEST_SUITE_INSTANCE, AssertTestSuiteInstance);
#line 4 "../src/libassert/libassert.vala"
	_g_object_unref0 (self->priv->cases);
#line 5 "../src/libassert/libassert.vala"
	_g_free0 (self->priv->name);
#line 3 "../src/libassert/libassert.vala"
	G_OBJECT_CLASS (assert_test_suite_instance_parent_class)->finalize (obj);
#line 555 "libassert.c"
}

static GType
assert_test_suite_instance_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (AssertTestSuiteInstanceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) assert_test_suite_instance_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AssertTestSuiteInstance), 0, (GInstanceInitFunc) assert_test_suite_instance_instance_init, NULL };
	GType assert_test_suite_instance_type_id;
	assert_test_suite_instance_type_id = g_type_register_static (G_TYPE_OBJECT, "AssertTestSuiteInstance", &g_define_type_info, 0);
	AssertTestSuiteInstance_private_offset = g_type_add_instance_private (assert_test_suite_instance_type_id, sizeof (AssertTestSuiteInstancePrivate));
	return assert_test_suite_instance_type_id;
}

GType
assert_test_suite_instance_get_type (void)
{
	static volatile gsize assert_test_suite_instance_type_id__volatile = 0;
	if (g_once_init_enter (&assert_test_suite_instance_type_id__volatile)) {
		GType assert_test_suite_instance_type_id;
		assert_test_suite_instance_type_id = assert_test_suite_instance_get_type_once ();
		g_once_init_leave (&assert_test_suite_instance_type_id__volatile, assert_test_suite_instance_type_id);
	}
	return assert_test_suite_instance_type_id__volatile;
}

void
assert_named_test_case_copy (const AssertNamedTestCase* self,
                             AssertNamedTestCase* dest)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	AssertTestCase _tmp2_;
	gpointer _tmp2__target;
#line 41 "../src/libassert/libassert.vala"
	_tmp0_ = (*self).name;
#line 41 "../src/libassert/libassert.vala"
	_tmp1_ = g_strdup (_tmp0_);
#line 41 "../src/libassert/libassert.vala"
	_g_free0 ((*dest).name);
#line 41 "../src/libassert/libassert.vala"
	(*dest).name = _tmp1_;
#line 41 "../src/libassert/libassert.vala"
	_tmp2_ = (*self).tcase;
#line 41 "../src/libassert/libassert.vala"
	_tmp2__target = (*self).tcase_target;
#line 41 "../src/libassert/libassert.vala"
	((*dest).tcase_target_destroy_notify == NULL) ? NULL : ((*dest).tcase_target_destroy_notify ((*dest).tcase_target), NULL);
#line 41 "../src/libassert/libassert.vala"
	(*dest).tcase = NULL;
#line 41 "../src/libassert/libassert.vala"
	(*dest).tcase_target = NULL;
#line 41 "../src/libassert/libassert.vala"
	(*dest).tcase_target_destroy_notify = NULL;
#line 41 "../src/libassert/libassert.vala"
	(*dest).tcase = _tmp2_;
#line 41 "../src/libassert/libassert.vala"
	(*dest).tcase_target = _tmp2__target;
#line 41 "../src/libassert/libassert.vala"
	(*dest).tcase_target_destroy_notify = NULL;
#line 614 "libassert.c"
}

void
assert_named_test_case_destroy (AssertNamedTestCase* self)
{
#line 42 "../src/libassert/libassert.vala"
	_g_free0 ((*self).name);
#line 43 "../src/libassert/libassert.vala"
	((*self).tcase_target_destroy_notify == NULL) ? NULL : ((*self).tcase_target_destroy_notify ((*self).tcase_target), NULL);
#line 43 "../src/libassert/libassert.vala"
	(*self).tcase = NULL;
#line 43 "../src/libassert/libassert.vala"
	(*self).tcase_target = NULL;
#line 43 "../src/libassert/libassert.vala"
	(*self).tcase_target_destroy_notify = NULL;
#line 630 "libassert.c"
}

AssertNamedTestCase*
assert_named_test_case_dup (const AssertNamedTestCase* self)
{
	AssertNamedTestCase* dup;
#line 41 "../src/libassert/libassert.vala"
	dup = g_new0 (AssertNamedTestCase, 1);
#line 41 "../src/libassert/libassert.vala"
	assert_named_test_case_copy (self, dup);
#line 41 "../src/libassert/libassert.vala"
	return dup;
#line 643 "libassert.c"
}

void
assert_named_test_case_free (AssertNamedTestCase* self)
{
#line 41 "../src/libassert/libassert.vala"
	assert_named_test_case_destroy (self);
#line 41 "../src/libassert/libassert.vala"
	g_free (self);
#line 653 "libassert.c"
}

static GType
assert_named_test_case_get_type_once (void)
{
	GType assert_named_test_case_type_id;
	assert_named_test_case_type_id = g_boxed_type_register_static ("AssertNamedTestCase", (GBoxedCopyFunc) assert_named_test_case_dup, (GBoxedFreeFunc) assert_named_test_case_free);
	return assert_named_test_case_type_id;
}

GType
assert_named_test_case_get_type (void)
{
	static volatile gsize assert_named_test_case_type_id__volatile = 0;
	if (g_once_init_enter (&assert_named_test_case_type_id__volatile)) {
		GType assert_named_test_case_type_id;
		assert_named_test_case_type_id = assert_named_test_case_get_type_once ();
		g_once_init_leave (&assert_named_test_case_type_id__volatile, assert_named_test_case_type_id);
	}
	return assert_named_test_case_type_id__volatile;
}

AssertTestSuiteInstance*
assert_suite (const gchar* name,
              AssertTestSuite tsuite,
              gpointer tsuite_target)
{
	AssertTestSuiteInstance* instance = NULL;
	AssertTestSuiteInstance* _tmp0_;
	AssertTestSuiteInstance* result = NULL;
#line 45 "../src/libassert/libassert.vala"
	g_return_val_if_fail (name != NULL, NULL);
#line 46 "../src/libassert/libassert.vala"
	_tmp0_ = assert_test_suite_instance_new ();
#line 46 "../src/libassert/libassert.vala"
	instance = _tmp0_;
#line 47 "../src/libassert/libassert.vala"
	tsuite (instance, tsuite_target);
#line 48 "../src/libassert/libassert.vala"
	result = instance;
#line 48 "../src/libassert/libassert.vala"
	return result;
#line 696 "libassert.c"
}

AssertAssertionResult*
assert_assertion_result_construct_error (GType object_type,
                                         const gchar* message)
{
	AssertAssertionResult* self = NULL;
	gchar* _tmp0_;
#line 53 "../src/libassert/libassert.vala"
	g_return_val_if_fail (message != NULL, NULL);
#line 53 "../src/libassert/libassert.vala"
	self = (AssertAssertionResult*) g_type_create_instance (object_type);
#line 54 "../src/libassert/libassert.vala"
	self->is_error = TRUE;
#line 55 "../src/libassert/libassert.vala"
	_tmp0_ = g_strdup (message);
#line 55 "../src/libassert/libassert.vala"
	_g_free0 (self->message);
#line 55 "../src/libassert/libassert.vala"
	self->message = _tmp0_;
#line 53 "../src/libassert/libassert.vala"
	return self;
#line 719 "libassert.c"
}

AssertAssertionResult*
assert_assertion_result_new_error (const gchar* message)
{
#line 53 "../src/libassert/libassert.vala"
	return assert_assertion_result_construct_error (ASSERT_TYPE_ASSERTION_RESULT, message);
#line 727 "libassert.c"
}

AssertAssertionResult*
assert_assertion_result_construct_success (GType object_type)
{
	AssertAssertionResult* self = NULL;
#line 57 "../src/libassert/libassert.vala"
	self = (AssertAssertionResult*) g_type_create_instance (object_type);
#line 58 "../src/libassert/libassert.vala"
	self->is_error = FALSE;
#line 57 "../src/libassert/libassert.vala"
	return self;
#line 740 "libassert.c"
}

AssertAssertionResult*
assert_assertion_result_new_success (void)
{
#line 57 "../src/libassert/libassert.vala"
	return assert_assertion_result_construct_success (ASSERT_TYPE_ASSERTION_RESULT);
#line 748 "libassert.c"
}

AssertAssertionResult*
assert_assertion_result_construct (GType object_type)
{
	AssertAssertionResult* self = NULL;
#line 50 "../src/libassert/libassert.vala"
	self = (AssertAssertionResult*) g_type_create_instance (object_type);
#line 50 "../src/libassert/libassert.vala"
	return self;
#line 759 "libassert.c"
}

AssertAssertionResult*
assert_assertion_result_new (void)
{
#line 50 "../src/libassert/libassert.vala"
	return assert_assertion_result_construct (ASSERT_TYPE_ASSERTION_RESULT);
#line 767 "libassert.c"
}

static void
assert_value_assertion_result_init (GValue* value)
{
#line 50 "../src/libassert/libassert.vala"
	value->data[0].v_pointer = NULL;
#line 775 "libassert.c"
}

static void
assert_value_assertion_result_free_value (GValue* value)
{
#line 50 "../src/libassert/libassert.vala"
	if (value->data[0].v_pointer) {
#line 50 "../src/libassert/libassert.vala"
		assert_assertion_result_unref (value->data[0].v_pointer);
#line 785 "libassert.c"
	}
}

static void
assert_value_assertion_result_copy_value (const GValue* src_value,
                                          GValue* dest_value)
{
#line 50 "../src/libassert/libassert.vala"
	if (src_value->data[0].v_pointer) {
#line 50 "../src/libassert/libassert.vala"
		dest_value->data[0].v_pointer = assert_assertion_result_ref (src_value->data[0].v_pointer);
#line 797 "libassert.c"
	} else {
#line 50 "../src/libassert/libassert.vala"
		dest_value->data[0].v_pointer = NULL;
#line 801 "libassert.c"
	}
}

static gpointer
assert_value_assertion_result_peek_pointer (const GValue* value)
{
#line 50 "../src/libassert/libassert.vala"
	return value->data[0].v_pointer;
#line 810 "libassert.c"
}

static gchar*
assert_value_assertion_result_collect_value (GValue* value,
                                             guint n_collect_values,
                                             GTypeCValue* collect_values,
                                             guint collect_flags)
{
#line 50 "../src/libassert/libassert.vala"
	if (collect_values[0].v_pointer) {
#line 821 "libassert.c"
		AssertAssertionResult * object;
		object = collect_values[0].v_pointer;
#line 50 "../src/libassert/libassert.vala"
		if (object->parent_instance.g_class == NULL) {
#line 50 "../src/libassert/libassert.vala"
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
#line 828 "libassert.c"
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
#line 50 "../src/libassert/libassert.vala"
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
#line 832 "libassert.c"
		}
#line 50 "../src/libassert/libassert.vala"
		value->data[0].v_pointer = assert_assertion_result_ref (object);
#line 836 "libassert.c"
	} else {
#line 50 "../src/libassert/libassert.vala"
		value->data[0].v_pointer = NULL;
#line 840 "libassert.c"
	}
#line 50 "../src/libassert/libassert.vala"
	return NULL;
#line 844 "libassert.c"
}

static gchar*
assert_value_assertion_result_lcopy_value (const GValue* value,
                                           guint n_collect_values,
                                           GTypeCValue* collect_values,
                                           guint collect_flags)
{
	AssertAssertionResult ** object_p;
	object_p = collect_values[0].v_pointer;
#line 50 "../src/libassert/libassert.vala"
	if (!object_p) {
#line 50 "../src/libassert/libassert.vala"
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
#line 859 "libassert.c"
	}
#line 50 "../src/libassert/libassert.vala"
	if (!value->data[0].v_pointer) {
#line 50 "../src/libassert/libassert.vala"
		*object_p = NULL;
#line 865 "libassert.c"
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
#line 50 "../src/libassert/libassert.vala"
		*object_p = value->data[0].v_pointer;
#line 869 "libassert.c"
	} else {
#line 50 "../src/libassert/libassert.vala"
		*object_p = assert_assertion_result_ref (value->data[0].v_pointer);
#line 873 "libassert.c"
	}
#line 50 "../src/libassert/libassert.vala"
	return NULL;
#line 877 "libassert.c"
}

GParamSpec*
assert_param_spec_assertion_result (const gchar* name,
                                    const gchar* nick,
                                    const gchar* blurb,
                                    GType object_type,
                                    GParamFlags flags)
{
	AssertParamSpecAssertionResult* spec;
#line 50 "../src/libassert/libassert.vala"
	g_return_val_if_fail (g_type_is_a (object_type, ASSERT_TYPE_ASSERTION_RESULT), NULL);
#line 50 "../src/libassert/libassert.vala"
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
#line 50 "../src/libassert/libassert.vala"
	G_PARAM_SPEC (spec)->value_type = object_type;
#line 50 "../src/libassert/libassert.vala"
	return G_PARAM_SPEC (spec);
#line 896 "libassert.c"
}

gpointer
assert_value_get_assertion_result (const GValue* value)
{
#line 50 "../src/libassert/libassert.vala"
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ASSERT_TYPE_ASSERTION_RESULT), NULL);
#line 50 "../src/libassert/libassert.vala"
	return value->data[0].v_pointer;
#line 906 "libassert.c"
}

void
assert_value_set_assertion_result (GValue* value,
                                   gpointer v_object)
{
	AssertAssertionResult * old;
#line 50 "../src/libassert/libassert.vala"
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ASSERT_TYPE_ASSERTION_RESULT));
#line 50 "../src/libassert/libassert.vala"
	old = value->data[0].v_pointer;
#line 50 "../src/libassert/libassert.vala"
	if (v_object) {
#line 50 "../src/libassert/libassert.vala"
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ASSERT_TYPE_ASSERTION_RESULT));
#line 50 "../src/libassert/libassert.vala"
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
#line 50 "../src/libassert/libassert.vala"
		value->data[0].v_pointer = v_object;
#line 50 "../src/libassert/libassert.vala"
		assert_assertion_result_ref (value->data[0].v_pointer);
#line 928 "libassert.c"
	} else {
#line 50 "../src/libassert/libassert.vala"
		value->data[0].v_pointer = NULL;
#line 932 "libassert.c"
	}
#line 50 "../src/libassert/libassert.vala"
	if (old) {
#line 50 "../src/libassert/libassert.vala"
		assert_assertion_result_unref (old);
#line 938 "libassert.c"
	}
}

void
assert_value_take_assertion_result (GValue* value,
                                    gpointer v_object)
{
	AssertAssertionResult * old;
#line 50 "../src/libassert/libassert.vala"
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ASSERT_TYPE_ASSERTION_RESULT));
#line 50 "../src/libassert/libassert.vala"
	old = value->data[0].v_pointer;
#line 50 "../src/libassert/libassert.vala"
	if (v_object) {
#line 50 "../src/libassert/libassert.vala"
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ASSERT_TYPE_ASSERTION_RESULT));
#line 50 "../src/libassert/libassert.vala"
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
#line 50 "../src/libassert/libassert.vala"
		value->data[0].v_pointer = v_object;
#line 959 "libassert.c"
	} else {
#line 50 "../src/libassert/libassert.vala"
		value->data[0].v_pointer = NULL;
#line 963 "libassert.c"
	}
#line 50 "../src/libassert/libassert.vala"
	if (old) {
#line 50 "../src/libassert/libassert.vala"
		assert_assertion_result_unref (old);
#line 969 "libassert.c"
	}
}

static void
assert_assertion_result_class_init (AssertAssertionResultClass * klass,
                                    gpointer klass_data)
{
#line 50 "../src/libassert/libassert.vala"
	assert_assertion_result_parent_class = g_type_class_peek_parent (klass);
#line 50 "../src/libassert/libassert.vala"
	((AssertAssertionResultClass *) klass)->finalize = assert_assertion_result_finalize;
#line 981 "libassert.c"
}

static void
assert_assertion_result_instance_init (AssertAssertionResult * self,
                                       gpointer klass)
{
#line 50 "../src/libassert/libassert.vala"
	self->ref_count = 1;
#line 990 "libassert.c"
}

static void
assert_assertion_result_finalize (AssertAssertionResult * obj)
{
	AssertAssertionResult * self;
#line 50 "../src/libassert/libassert.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, ASSERT_TYPE_ASSERTION_RESULT, AssertAssertionResult);
#line 50 "../src/libassert/libassert.vala"
	g_signal_handlers_destroy (self);
#line 52 "../src/libassert/libassert.vala"
	_g_free0 (self->message);
#line 1003 "libassert.c"
}

static GType
assert_assertion_result_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { assert_value_assertion_result_init, assert_value_assertion_result_free_value, assert_value_assertion_result_copy_value, assert_value_assertion_result_peek_pointer, "p", assert_value_assertion_result_collect_value, "p", assert_value_assertion_result_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (AssertAssertionResultClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) assert_assertion_result_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (AssertAssertionResult), 0, (GInstanceInitFunc) assert_assertion_result_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType assert_assertion_result_type_id;
	assert_assertion_result_type_id = g_type_register_fundamental (g_type_fundamental_next (), "AssertAssertionResult", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return assert_assertion_result_type_id;
}

GType
assert_assertion_result_get_type (void)
{
	static volatile gsize assert_assertion_result_type_id__volatile = 0;
	if (g_once_init_enter (&assert_assertion_result_type_id__volatile)) {
		GType assert_assertion_result_type_id;
		assert_assertion_result_type_id = assert_assertion_result_get_type_once ();
		g_once_init_leave (&assert_assertion_result_type_id__volatile, assert_assertion_result_type_id);
	}
	return assert_assertion_result_type_id__volatile;
}

gpointer
assert_assertion_result_ref (gpointer instance)
{
	AssertAssertionResult * self;
	self = instance;
#line 50 "../src/libassert/libassert.vala"
	g_atomic_int_inc (&self->ref_count);
#line 50 "../src/libassert/libassert.vala"
	return instance;
#line 1038 "libassert.c"
}

void
assert_assertion_result_unref (gpointer instance)
{
	AssertAssertionResult * self;
	self = instance;
#line 50 "../src/libassert/libassert.vala"
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
#line 50 "../src/libassert/libassert.vala"
		ASSERT_ASSERTION_RESULT_GET_CLASS (self)->finalize (self);
#line 50 "../src/libassert/libassert.vala"
		g_type_free_instance ((GTypeInstance *) self);
#line 1052 "libassert.c"
	}
}

